#!/usr/bin/env scheme-script
;; -*- mode: scheme; coding: utf-8 -*-
;; The Minimum-Effort IRC bot
;; Copyright © 2008, 2009 Göran Weinholt <goran@weinholt.se>
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#!r6rs

(import (weinholt net irc)
        (weinholt net tcp)
        (only (srfi :13 strings) string-join)
        (rnrs))


;;; Configuration default

;; Nicknames to try, in order.
(define *nicknames* '("Industry" "Industry`" "Industry_"
                      "Zeal" "Zeal`" "Zeal_"))
(define *nickname* (car *nicknames*))
(define *realname* "The Minimum-Effort IRC bot")
(define *username* "meircbot")
(define *channels* '("#test"))
(define *joined-channels* '())
(define *isupport* (isupport-defaults))

(define *server-hostname* "localhost")
(define *server-port* "6667")

;; Incoming messages will be transcoded with utf-8 and if that fails,
;; fall back on latin-1.
(define *outgoing-codec* (utf-8-codec))
(define transcode-incoming
  (let ((t1 (make-transcoder (utf-8-codec)
                             (eol-style none)
                             (error-handling-mode raise)))
        (t2 (make-transcoder (latin-1-codec))))
    (lambda (bv)
      (guard (con
              ((i/o-decoding-error? con)
               (bytevector->string bv t2)))
        (bytevector->string bv t1)))))

;;; Helpers

(define (print . x) (for-each display x) (newline))

(define (binary-get-line port)
  (let lp ((l '()))
    (let ((b (get-u8 port)))
      (cond ((and (eof-object? b) (null? l))
             b)
            ((eof-object? b)
             (u8-list->bytevector (reverse l)))
            ((= b (char->integer #\linefeed))
             (if (null? l)
                 '#vu8()
                 (if (= (car l) (char->integer #\return))
                     (u8-list->bytevector (reverse (cdr l)))
                     (u8-list->bytevector (reverse l)))))
            (else
             (lp (cons b l)))))))

(define (its-me? nick)
  (and nick (string-irc=? nick *nickname* (assq 'CASEMAPPING *isupport*))))

;;; Main program

(define *server-out* #f)

(define (log-msg direction prefix cmd args)
  (display direction) (display #\space)
  (display prefix) (display #\space)
  (display cmd) (display #\space)
  (write args)
  (newline))

(define (fmt cmd . args)
  (log-msg '=> #f cmd args)
  (apply format-message-with-whitewash *server-out* *outgoing-codec* #f cmd args)
  (flush-output-port *server-out*))

(define (handle-message prefix nick-src cmd args)
  (log-msg '<= prefix cmd args)
  (case cmd
    ((PING)
     (fmt 'PONG (car args)))

    ((PRIVMSG)
     (when (and nick-src (= (length args) 2))
       (cond ((its-me? (car args))
              ;; Private message
              (let ((msg (cadr args)))
                (if (ctcp-message? msg)
                    (fmt 'NOTICE nick-src "I don't support CTCP!")
                    (fmt 'NOTICE nick-src "Whaddaya want?")))
              #f)
             ((exists (lambda (c) (string-ci=? c (car args)))
                      *joined-channels*)
              ;; Public message to a channel
              #f))))

    ((433)
     ;; ERR_NICKNAMEINUSE
     (set! *nicknames* (cdr *nicknames*))
     (when (null? *nicknames*)
       (display "All nicknames are taken, giving up!\n")
       (exit 1))
     (set! *nickname* (car *nicknames*))
     (fmt 'NICK *nickname*))

    ((NICK)
     (when (its-me? nick-src)
       ;; The server changed our nick
       (set! *nickname* (car args))))

    ((JOIN)
     (when (its-me? nick-src)
       ;; The server joined us to a channel
       (set! *joined-channels*
             (cons (car args)
                   *joined-channels*))
       (print "Currently joined to " (string-join *joined-channels* ", "))))

    ((PART)
     (when (its-me? nick-src)
       ;; The server parted us from a channel
       (set! *joined-channels*
             (remp (lambda (x) (string-ci=? x (car args)))
                   *joined-channels*))
       (print "Currently joined to " (string-join *joined-channels* ", "))))

    ((001)
     ;; RPL_WELCOME
     (for-each (lambda (c)
                 (if (pair? c)
                     (fmt 'JOIN (car c) (cdr c))
                     (fmt 'JOIN c)))
               *channels*))

    ((005)
     ;; RPL_BOUNCE in the RFCs, but in practice, RPL_ISUPPORT.
     (set! *isupport* (append (parse-isupport (cdr args))
                              *isupport*)))))


;; main loop
(let-values (((in out) (tcp-connect *server-hostname* *server-port*)))
  (set! *server-out* out)
  (fmt 'NICK *nickname*)
  (fmt 'USER *username* 0 "*" *realname*)
  (let lp ()
    (let ((line (binary-get-line in)))
      (cond ((eof-object? line)
             (print "The server hung up on me!"))
            (else
             (guard (exn
                     (else
                      (write exn) (newline)
                      (print "The exception above was raised while parsing this line: " line)))
               (let-values (((prefix cmd parameters) (parse-message-bytevector line)))
                 (handle-message prefix (and (extended-prefix? prefix) (prefix-nick prefix))
                                 cmd (map transcode-incoming parameters))))
             (lp))))))
