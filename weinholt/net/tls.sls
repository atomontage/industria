;; -*- mode: scheme; coding: utf-8 -*-
;; Copyright © 2009, 2010 Göran Weinholt <goran@weinholt.se>
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#!r6rs

;; Transport Layer Security. RFC5246.

;; This library is under development and currently only works as a
;; quite slow client. It uses RSA to negotiate a master secret, 3DES
;; to encode data and SHA-1 to protect integrity.

;; The security of TLS in essence works like this: the server sends a
;; list of certificates, each signed by the next. The last certificate
;; is signed by a root certificate which you are supposed to have
;; downloaded from a trusted party. The first certificate contains the
;; server's public key. A few random bytes are generated by both the
;; client and the server. Then the client generates a few random bytes
;; that are called the premaster-secret and it encrypts them against
;; the server's public key. The server decrypts this and both sides
;; now have access to the premaster-secret without anyone being able
;; to read it off the network. Now both sides use all these random
;; numbers to generate the master secret and then use it to generate
;; key material for a symmetric cipher like 3DES. When this is done,
;; all messages have their checksums calculated with something like
;; SHA-1 and then encrypted with the cipher.

;; http://www.ietf.org/dyn/wg/charter/tls-charter.html

;; TODO: go through the implementation pitfalls in the RFC.

(library (weinholt net tls (0 0 20100613))
  (export make-tls-wrapper
          flush-tls-output
          put-tls-record get-tls-record
          put-tls-alert-record
          put-tls-handshake
          put-tls-handshake-client-hello
          put-tls-handshake-certificate
          put-tls-handshake-client-key-exchange
          put-tls-handshake-certificate-verify
          put-tls-change-cipher-spec
          put-tls-handshake-finished
          put-tls-application-data
          tls-conn-remote-certs
          tls-conn-has-unprocessed-data?)
  (import (rnrs)
          (only (srfi :1 lists) last)
          (srfi :19 time)
          (srfi :27 random-bits)
          (weinholt bytevectors)
          (weinholt crypto des)
          (weinholt crypto entropy)
          (weinholt crypto sha-1)
          (weinholt crypto md5)
          (weinholt crypto rsa)
          (weinholt crypto x509)
          (weinholt net buffer)
          (weinholt struct pack))

  (define TLS-VERSION-1.2 #x0303)
  (define TLS-VERSION-1.1 #x0302)
  (define TLS-VERSION-1.0 #x0301)
  (define SSL-VERSION-3.0 #x0300)       ;not gonna be supported
  (define TLS-VERSION TLS-VERSION-1.0)
  ;; TODO: fix the IV thing and upgrade to 1.1
  ;; TODO: implement tls-prf-sha256 and aes and upgrade to version 1.2
  (define tls-client-version-bytevector
    (pack "!S" TLS-VERSION))

  ;; A few cipher suites
  (define TLS-NULL-WITH-NULL-NULL #x0000)
  (define TLS-RSA-WITH-NULL-MD5 #x0001)
  (define TLS-RSA-WITH-NULL-SHA #x0002)
  (define TLS-RSA-WITH-NULL-SHA256 #x003B)
  (define TLS-RSA-WITH-RC4-128-MD5 #x0004)
  (define TLS-RSA-WITH-RC4-128-SHA #x0005)
  (define TLS-RSA-WITH-3DES-EDE-CBC-SHA #x000A) ;only one implemented
  (define TLS-RSA-WITH-AES-128-CBC-SHA #x002F)
  (define TLS-RSA-WITH-AES-256-CBC-SHA #x0035)
  (define TLS-RSA-WITH-AES-128-CBC-SHA256 #x003C)
  (define TLS-RSA-WITH-AES-256-CBC-SHA256 #x003D)

  (define-syntax print
    (syntax-rules ()
      #;
      ((_ . args)
       (begin
         (for-each display (list . args))
         (newline)))
      ((_ . args) (values))))

  (define (bv->string bv)
    (apply string-append
           (map (lambda (b)
                  (if (< b #x10)
                      (string-append "0" (number->string b 16))
                      (number->string b 16)))
                (bytevector->u8-list bv))))

  (define (bytevector-copy* bv start len)
    (let ((ret (make-bytevector len)))
      (bytevector-copy! bv start ret 0 len)
      ret))

  (define (u16be-list->bytevector x)
    (uint-list->bytevector x (endianness big) 2))

  (define (tls-prf-sha256 bytes secret label seeds)
    (error 'tls-prf-sha256 "not implemented"))

  (define (p-hash hash->bytevector hmac hash-length length secret seeds)
    ;; Expands the secret and seeds to at least `length' bytes, which
    ;; will be rounded to a multiple of the hash-length.
    (define (gen-A i max prev)
      (if (fx=? i max)
          '()
          (let ((a (hash->bytevector (hmac secret prev))))
            (cons prev (gen-A (fx+ i 1) max a)))))
    (bytevector-concatenate
     (map (lambda (a) (hash->bytevector (apply hmac secret a seeds)))
          (gen-A 0
                 (div (+ length (- hash-length 1)) hash-length)
                 (hash->bytevector (apply hmac secret seeds))))))

  (define (tls-prf-md5-sha1 bytes secret label seeds)
    ;; Performs this operation from RFC4346:
    ;; PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
    ;;                          P_SHA-1(S2, label + seed)
    (let* ((half-length (div (+ (bytevector-length secret) 1) 2))
           (s1 (subbytevector secret 0 half-length))
           (s2 (subbytevector secret half-length))
           (seeds (cons label seeds)))
      (do ((p1 (p-hash md5->bytevector hmac-md5 16 bytes s1 seeds))
           (p2 (p-hash sha-1->bytevector hmac-sha-1 20 bytes s2 seeds))
           (i 0 (fx+ i 1))
           (ret (make-bytevector bytes)))
          ((= i bytes) ret)
        (bytevector-u8-set! ret i (fxxor (bytevector-u8-ref p1 i)
                                         (bytevector-u8-ref p2 i))))))

  (define-record-type tls-conn
    (fields (mutable client-cipher)
            (mutable server-cipher)
            (mutable compression)
            (mutable mac-key)
            (mutable seq-read)
            (mutable seq-write)
            (mutable version)
            (mutable remote-certs)      ;end-entity is last
            (mutable server-key)
            (mutable server-random)
            (mutable client-random)
            (mutable prf)
            (mutable master-secret)
            (mutable client-write-mac-secret)
            (mutable client-write-key)
            (mutable client-write-IV)
            (mutable server-write-mac-secret)
            (mutable server-write-key)
            (mutable server-write-IV)
            (immutable handshakes-md5)
            (immutable handshakes-sha-1)
            (immutable server-name)
            (immutable inbuf)           ;buffer for record input
            (immutable out)             ;output port
            (immutable hsbuf)))         ;handshake buffer

  ;; Make a new TLS connection state.
  (define (make-tls-wrapper in out server-name)
    (let ((random-source (make-random-source)))
      (random-source-randomize! random-source)
      (make-tls-conn TLS-NULL-WITH-NULL-NULL
                     TLS-NULL-WITH-NULL-NULL
                     #f
                     #f
                     0 0
                     TLS-VERSION
                     '()
                     'no-server-key-yet
                     'no-server-random
                     'no-client-random
                     'no-prf-yet
                     'no-master-secret-yet
                     'no-client-write-mac-secret-yet
                     'no-client-write-key-yet
                     'no-client-write-IV-yet
                     'no-server-write-mac-secret-yet
                     'no-server-write-key-yet
                     'no-server-write-IV-yet
                     (make-md5)
                     (make-sha-1)
                     server-name
                     (make-buffer in)
                     out
                     (make-buffer 'handshakes))))

  (define (close-tls conn)
    ;; TODO: clear the connection state
    (close-port (tls-conn-out conn))
    (close-port (buffer-port (tls-conn-inbuf conn))))


;;; Record protocol

  ;; The record layer receives fragments (that are optionally
  ;; encrypted and/or compressed). These fragments are sent to a
  ;; higher level protocol (change-cipher-spec, alert, handshake or
  ;; application-data). Fragments headed for change-cipher-spec and
  ;; application-data can never be incomplete, so for these protocols
  ;; the normal tls-conn-inbuf is used. Handshakes get their own
  ;; buffer: tls-conn-hsbuf. The alert protocol could possibly contain
  ;; fragments, but is that really something that happens?

  (define TLS-PROTOCOL-CHANGE-CIPHER-SPEC 20)
  (define TLS-PROTOCOL-ALERT 21)
  (define TLS-PROTOCOL-HANDSHAKE 22)
  (define TLS-PROTOCOL-APPLICATION-DATA 23)

  (define (flush-tls-output conn)
    (flush-output-port (tls-conn-out conn)))

  (define (put-tls-record conn type data)
    ;; Take a list of data, split it into records and put the records
    ;; on the output port.
    (print ";;; sending a record of type " type)
    (let ((out (tls-conn-out conn))
          (len (bytevectors-length data)))
      (put-u8 out type)
      ;; TLS version
      (put-u8 out (bitwise-arithmetic-shift-right (tls-conn-version conn) 8))
      (put-u8 out (fxand #xff (tls-conn-version conn)))

      (cond ((>= len (+ (expt 2 14) 2048))
             (error 'put-tls-record "TODO: overlong record" len))
            ((= (tls-conn-client-cipher conn) TLS-NULL-WITH-NULL-NULL)
             (put-u8 out (fxand #xff (bitwise-arithmetic-shift-right len 8)))
             (put-u8 out (fxand #xff len))
             (for-each (lambda (bv) (put-bytevector out bv)) data))
            (else
             (let* ((blocks-len (fx+ len 21))  ;content+sha-1+padbyte
                    ;; TODO: more than the minimum padding
                    (padding (- (fxand (fx+ blocks-len 7) -8)
                                blocks-len))
                    (padded-len (+ blocks-len padding))
                    (blocks (make-bytevector padded-len padding)))

               (print "#;outgoing-plaintext " data)
               ;; TODO: if the sequence numbers exceed 2^64-1, renegotiate

               (sha-1-copy-hash! (apply hmac-sha-1
                                        (tls-conn-client-write-mac-secret conn)
                                        (pack "!uQCSS" (tls-conn-seq-write conn)
                                              type (tls-conn-version conn) len)
                                        data)
                                 blocks len)

               (tls-conn-seq-write-set! conn (+ (tls-conn-seq-write conn) 1))
               (let ((plaintext (bytevector-concatenate data)))
                 (bytevector-copy! plaintext 0
                                   blocks 0
                                   (bytevector-length plaintext)))

               ;; Encipher with 3DES-CBC
               (tdea-cbc-encipher! blocks
                                   (tls-conn-client-write-key conn)
                                   (tls-conn-client-write-IV conn)
                                   0 padded-len)

               (print "#;outgoing-ciphertext " blocks)
               (put-u8 out (fxand #xff (bitwise-arithmetic-shift-right padded-len 8)))
               (put-u8 out (fxand #xff padded-len))
               (put-bytevector out blocks))))))

  (define (tls-conn-has-unprocessed-data? conn)
    (cond ((not (zero? (buffer-length (tls-conn-hsbuf conn))))
           (print ";Handshake protocol has " (buffer-length (tls-conn-hsbuf conn))
                  " bytes unprocessed")
           TLS-PROTOCOL-HANDSHAKE)
          (else #f)))
  
  (define (get-tls-record conn)
    (buffer-reset! (tls-conn-inbuf conn))
    (cond ((tls-conn-has-unprocessed-data? conn) =>
           (lambda (type)
             (print ";Handling unprocessed data of type " type)
             (handle-fragment conn (tls-conn-inbuf conn) type)))
          ((port-eof? (buffer-port (tls-conn-inbuf conn)))
           (eof-object))
          (else
           (get-tls-record* conn))))

  (define (get-tls-record* conn)
    (let ((b (tls-conn-inbuf conn)))
      (buffer-read! b (format-size "!uCSS"))
      (let-values (((type version len) (unpack "!uCSS" (buffer-data b))))
        (print ";;; record type: " type
               " version: " (number->string version 16)
               " length: " len)
        (when (>= len (+ (expt 2 14) 2048))
          (error 'get-tls-record "The server sent an overlong record"
                 (tls-conn-server-name conn)))
        (buffer-reset! b)
        (buffer-read! b len)
        (decipher-record conn b type len)
        (handle-fragment conn b type))))

  (define (decipher-record conn b type len)
    (cond ((= (tls-conn-server-cipher conn) TLS-RSA-WITH-3DES-EDE-CBC-SHA)
           (print ";Deciphering 3DES encrypted record")
           (tdea-cbc-decipher! (buffer-data b)
                               (tls-conn-server-write-key conn)
                               (tls-conn-server-write-IV conn)
                               (buffer-top b)
                               len)
           (let ((padding (bytevector-u8-ref (buffer-data b) (- (buffer-bottom b) 1))))
             ;; FIXME: verify the MAC even if the padding is crazy
             (print "#;padding " padding)
             (buffer-bottom-set! b (- (buffer-bottom b) padding 1)) ;remove padding
             (let ((mac (subbytevector (buffer-data b) (- (buffer-bottom b) 20)
                                       (buffer-bottom b))))
               (buffer-bottom-set! b (- (buffer-bottom b) 20)) ;remove MAC
               (unless (bytevector=? mac
                                     (sha-1->bytevector
                                      (hmac-sha-1
                                       (tls-conn-server-write-mac-secret conn)
                                       (pack "!uQCSS" (tls-conn-seq-read conn)
                                             type (tls-conn-version conn)
                                             (buffer-length b))
                                       (subbytevector (buffer-data b)
                                                      (buffer-top b)
                                                      (buffer-bottom b)))))
                 (error 'get-tls-record "bad mac" (tls-conn-server-name conn)))
               (tls-conn-seq-read-set! conn (+ (tls-conn-seq-read conn) 1)))))))

  (define (handle-fragment conn b type)
    ;; At the start of the buffer b is a plaintext fragment.
    (cond ((= type TLS-PROTOCOL-APPLICATION-DATA)
           (get-tls-application-data conn)) ;never fragmented
          ((= type TLS-PROTOCOL-CHANGE-CIPHER-SPEC)
           (get-tls-change-cipher-spec conn)) ;never fragmented
          ((= type TLS-PROTOCOL-ALERT)  ;FIXME: could be fragmented?
           (get-tls-alert-record conn))
          ((= type TLS-PROTOCOL-HANDSHAKE)
           (buffer-copy! (buffer-data b) (buffer-top b)
                         (tls-conn-hsbuf conn)
                         (buffer-length b))
           (get-tls-handshake-record conn))
          (else
           ;; TODO: send an error
           (close-tls conn)
           (error 'get-tls-record
                  "The server sent an invalid record type" type))))

;;; Alert protocol

  ;; TODO: friendly messages for all these alerts
  (define alert-descriptions
    '((0 . close-notify)
      (10 . unexpected-message)
      (20 . bad-record-mac)
      (21 . decryption-failed-RESERVED) ;never send this
      (22 . record-overflow)
      (30 . decompression-failure)
      (40 . handshake-failure)
      (41 . no-certificate-RESERVED)    ;deprecated
      (42 . bad-certificate)
      (43 . unsupported-certificate)
      (44 . certificate-revoked)
      (45 . certificate-expired)
      (46 . certificate-unknown)
      (47 . illegal-parameter)
      (48 . unknown-ca)
      (49 . access-denied)
      (50 . decode-error)
      (51 . decrypt-error)
      (60 . export-restriction-RESERVED) ;deprecated
      (70 . protocol-version)
      (71 . insufficient-security)
      (80 . internal-error)
      (90 . user-canceled)
      (100 . no-renegotiation)
      (110 . unsupported-extension)))

  (define (get-tls-alert-record conn)
    (let* ((b (tls-conn-inbuf conn))
           (level (read-u8 b 0))
           (description (read-u8 b 1))
           (desc* (or (assq description alert-descriptions)
                      (cons description 'unknown-alert-description))))
      (cond ((= level 2)
             (close-tls conn)
             (condition
              (make-error)
              (make-i/o-error)
              (make-i/o-port-error (buffer-port (tls-conn-inbuf conn)))
              (make-message-condition "TLS alert (fatal, port closed)")
              (make-irritants-condition (list desc*))))
            ((= level 1)
             (condition
              (make-warning)
              (make-i/o-port-error (buffer-port (tls-conn-inbuf conn)))
              (make-message-condition "TLS alert (warning)")
              (make-irritants-condition (list desc*))))
            ;; TODO: other levels give errors...
            )))

  (define (put-tls-alert-record conn level description)
    (assert (memv level '(1 2)))
    (put-tls-record conn TLS-PROTOCOL-HANDSHAKE
                    (list (pack "!CC" level description))))

;;; Handshake protocol

  (define TLS-HANDSHAKE-HELLO-REQUEST 0)
  (define TLS-HANDSHAKE-CLIENT-HELLO 1)
  (define TLS-HANDSHAKE-SERVER-HELLO 2)
  (define TLS-HANDSHAKE-CERTIFICATE 11)
  (define TLS-HANDSHAKE-SERVER-KEY-EXCHANGE 12)
  (define TLS-HANDSHAKE-CERTIFICATE-REQUEST 13)
  (define TLS-HANDSHAKE-SERVER-HELLO-DONE 14)
  (define TLS-HANDSHAKE-CERTIFICATE-VERIFY 15)
  (define TLS-HANDSHAKE-CLIENT-KEY-EXCHANGE 16)
  (define TLS-HANDSHAKE-FINISHED 20)

  (define tls-conn-hash-handshake!
    (case-lambda
      ((conn l)
       (for-each (lambda (bv)
                   (tls-conn-hash-handshake! conn bv 0 (bytevector-length bv)))
                 l))
      ((conn bv start count)
       ;; Calculate the hashes of all incoming and outgoing
       ;; handshakes. Used in the FINISH message. TODO: this is
       ;; version-dependent.
       (md5-update! (tls-conn-handshakes-md5 conn) bv start (+ start count))
       (sha-1-update! (tls-conn-handshakes-sha-1 conn) bv start (+ start count)))))

  (define (put-tls-handshake conn type data)
    ;; Takes data from a handshake protocol and passes it to the
    ;; record protocol.
    (let ((bv (make-bytevector 4))
          (len (bytevectors-length data)))
      (bytevector-u32-set! bv 0 (bitwise-ior (bitwise-arithmetic-shift-left type 24)
                                             len)
                           (endianness big))
      (tls-conn-hash-handshake! conn (cons bv data))
      (put-tls-record conn TLS-PROTOCOL-HANDSHAKE (cons bv data))))

  (define (put-tls-handshake-client-hello conn)
    (define session-id '#vu8())
    (define cipher-suites (list TLS-RSA-WITH-3DES-EDE-CBC-SHA))
    (define compression-methods '(0))   ;null compression
    (let ((crandom (make-random-bytevector (+ 4 28))))
      ;; Client time + random bytes
      (bytevector-u32-set! crandom 0
                           (bitwise-and #xffffffff (time-second (current-time)))
                           (endianness big))
      (tls-conn-client-random-set! conn crandom)

      ;; Extensions (RFC4366).
      ;; http://www.iana.org/assignments/tls-extensiontype-values

      (let ((server-name (string->utf8 (tls-conn-server-name conn))))
        (put-tls-handshake
         conn TLS-HANDSHAKE-CLIENT-HELLO
         (list tls-client-version-bytevector
               crandom
               (pack "C" (bytevector-length session-id))
               session-id
               (pack "!S" (* 2 (length cipher-suites)))
               (u16be-list->bytevector cipher-suites)
               (u8-list->bytevector (cons (length compression-methods)
                                          compression-methods))
               (pack "!uS SS CS"
                     (+ (format-size "!uSSCS") (bytevector-length server-name))
                     0 ;server_name. FIXME: don't send IPs, etc
                     (+ (format-size "!uCS") (bytevector-length server-name))
                     0 ;HostName
                     (+ 1 (bytevector-length server-name)))
               server-name)))))

  ;; `certs' are bytevectors and the last cert is the client's own
  ;; certificate. So the order is the same as for
  ;; tls-conn-remote-certs.
  (define (put-tls-handshake-certificate conn certs)
    (define (put-u24 p n)
      (put-u8 p (bitwise-bit-field n 16 24))
      (put-u8 p (bitwise-bit-field n 8 16))
      (put-u8 p (bitwise-bit-field n 0 8)))
    (let ((certs (or certs '())))
      (let-values (((p extract) (open-bytevector-output-port)))
        (put-u24 p (+ (bytevectors-length certs)
                      (* 3 (length certs))))
        (for-each (lambda (c)
                    (put-u24 p (bytevector-length c))
                    (put-bytevector p c))
                  (reverse certs))
        (put-tls-handshake conn TLS-HANDSHAKE-CERTIFICATE
                           (list (extract))))))

  (define (put-tls-handshake-client-key-exchange conn)
    (let* ((premaster-secret (make-random-bytevector 48))
           (keylen (rsa-public-key-byte-length (tls-conn-server-key conn)))
           (bv (make-bytevector (+ 2 keylen))))
      ;; Construct the premaster secret with our version number and 46
      ;; random bytes. Everything hinges on this being unpredictable...
      (bytevector-u16-set! premaster-secret 0 TLS-VERSION (endianness big))

      (bytevector-u16-set! bv 0 keylen (endianness big))
      (bytevector-uint-set! bv 2
                            (rsa-pkcs1-encrypt premaster-secret
                                               (tls-conn-server-key conn))
                            (endianness big) keylen)
      (print ";plaintext premaster secret: " (bv->string premaster-secret))
      (print ";client random: " (bv->string (tls-conn-client-random conn)))
      (print ";server random: " (bv->string (tls-conn-server-random conn)))

      (tls-conn-master-secret-set! conn ((tls-conn-prf conn) 48
                                         premaster-secret
                                         (string->utf8 "master secret")
                                         (list (tls-conn-client-random conn)
                                               (tls-conn-server-random conn))))

      (print ";master secret: " (bv->string (tls-conn-master-secret conn)))

      ;; Generate cryptographical material from the master key
      (let* ((hash-size 20)             ;sha-1
             (key-size 24)              ;3des-cbc
             (IV-size 8)                ;3des-cbc
             (key-block ((tls-conn-prf conn) (* 2 (+ hash-size key-size IV-size))
                         (tls-conn-master-secret conn)
                         (string->utf8 "key expansion")
                         (list (tls-conn-server-random conn)
                               (tls-conn-client-random conn)))))

        (print ";key block: " (bv->string key-block))

        (tls-conn-client-write-mac-secret-set! conn (bytevector-copy*
                                                     key-block 0 hash-size))
        (tls-conn-server-write-mac-secret-set! conn (bytevector-copy*
                                                     key-block hash-size hash-size))
        (let ((client-write-key (bytevector-copy* key-block (* 2 hash-size) key-size))
              (server-write-key (bytevector-copy* key-block
                                                  (+ key-size (* 2 hash-size)) key-size)))
          (tls-conn-client-write-key-set! conn (tdea-permute-key client-write-key))
          (tls-conn-server-write-key-set! conn (tdea-permute-key server-write-key))
          (tls-conn-client-write-IV-set! conn (bytevector-copy* key-block
                                                                (+ (* 2 key-size)
                                                                   (* 2 hash-size))
                                                                IV-size))
          (tls-conn-server-write-IV-set! conn (bytevector-copy* key-block
                                                                (+ IV-size
                                                                   (* 2 key-size)
                                                                   (* 2 hash-size))
                                                                IV-size))

          (print ";client-write-mac-secret: "
                 (bv->string (tls-conn-client-write-mac-secret conn)))
          (print ";server-write-mac-secret: "
                 (bv->string (tls-conn-server-write-mac-secret conn)))
          (print ";client-write-key: " (bv->string client-write-key))
          (print ";server-write-key: " (bv->string server-write-key))
          (print ";client-write-IV: " (bv->string (tls-conn-client-write-IV conn)))
          (print ";server-write-IV: " (bv->string (tls-conn-server-write-IV conn)))

          (bytevector-fill! key-block 0)
          (bytevector-fill! premaster-secret 0)

          (put-tls-handshake conn TLS-HANDSHAKE-CLIENT-KEY-EXCHANGE
                             (list bv))))))

  (define (put-tls-handshake-certificate-verify conn)
    ;; This is the message to prove that the client has the private
    ;; key for the cert it sent.
    (error 'put-tls-handshake-certificate-verify
           "TODO: not yet implemented. client certificates not supported."))

  (define (put-tls-handshake-finished conn)
    ;; PRF(master_secret, finished_label, MD5(handshake_messages) +
    ;;                         SHA-1(handshake_messages)) [0..11];
    (put-tls-handshake conn TLS-HANDSHAKE-FINISHED
                       (list ((tls-conn-prf conn) 12
                              (tls-conn-master-secret conn)
                              (string->utf8 "client finished")
                              (list (md5->bytevector
                                     (md5-finish (tls-conn-handshakes-md5 conn)))
                                    (sha-1->bytevector
                                     (sha-1-finish (tls-conn-handshakes-sha-1 conn))))))))

  (define (get-tls-handshake-record conn)
    (let* ((b (tls-conn-hsbuf conn))
           (type (read-u8 b 0))
           (length (read-u24 b 1))
           (start (buffer-top b)))
      (define (hash!)
        (tls-conn-hash-handshake! conn
                                  (buffer-data b)
                                  start
                                  (+ 4 length)))
      (define (done!)
        (buffer-top-set! b (+ start 4 length))
        (when (zero? (buffer-length b)) ;end of record?
          (buffer-reset! b)))

      (buffer-seek! b 4)

      (cond ((> length (buffer-length b))
             (print ";Fragmented handshake (" (buffer-length b) " of " length ")")
             (print b)
             (buffer-seek! b -4)
             (get-tls-record conn))
            ((= type TLS-HANDSHAKE-SERVER-HELLO)
             ;; The server replied (presumably, check this later) to
             ;; the CLIENT-HELLO message.
             (hash!)
             (print ";Server says hello.")
             (tls-conn-version-set! conn (read-u16 b 0))
             (print ";Version " (number->string (tls-conn-version conn) 16))
             (cond ((= (tls-conn-version conn) TLS-VERSION-1.2)
                    (tls-conn-prf-set! conn tls-prf-sha256))
                   (else
                    (tls-conn-prf-set! conn tls-prf-md5-sha1)))

             (print ";Server time: " (read-u32 b 2))

             (tls-conn-server-random-set! conn
                                          (bytevector-copy*
                                           (buffer-data b)
                                           (+ 2 (buffer-top b))
                                           (+ 4 28)))

             (buffer-seek! b (+ 2 4 28))
             (print ";Session length: "  (read-u8 b 0))
             (buffer-seek! b (+ 1 (read-u8 b 0))) ;skip session

             (print ";Cipher suite: " (read-u16 b 0))
             (print ";Compression method: " (read-u8 b 2))
             (done!)
             'handshake-server-hello)

            ((= type TLS-HANDSHAKE-CERTIFICATE)
             (hash!)
             (print ";Server sends certificates")
             (let ((certs-end (+ (buffer-top b) 3 (read-u24 b 0))))
               (buffer-seek! b 3)
               (let lp ((certs '()))
                 (cond ((= certs-end (buffer-top b))
                        (tls-conn-server-key-set! conn (public-key<-certificate
                                                        (last certs)))
                        (tls-conn-remote-certs-set! conn certs)
                        (done!)
                        'handshake-certificate)
                       (else
                        (let* ((cert-len (read-u24 b 0))
                               (cert (certificate<-bytevector (buffer-data b)
                                                              (+ 3 (buffer-top b))
                                                              (+ 3 (buffer-top b)
                                                                 cert-len))))
                          (print ";Cert of length " cert-len)
                          (print "#;cert " (bytevector-copy* (buffer-data b)
                                                             (+ 3 (buffer-top b))
                                                             cert-len))
                          (buffer-seek! b (+ cert-len 3))
                          (lp (cons cert certs))))))))

            ((= type TLS-HANDSHAKE-SERVER-HELLO-DONE)
             (hash!)
             (done!)
             'handshake-server-hello-done)

            ((= type TLS-HANDSHAKE-CERTIFICATE-REQUEST)
             (hash!)
             (done!)
             'handshake-certificate-request)

            ((= type TLS-HANDSHAKE-FINISHED)
             ;; If this message is correct, it proves that the server
             ;; could decrypt the pre-master secret, so it has the
             ;; private key for the certificate it sent.
             (unless (bytevector=? (bytevector-copy* (buffer-data b)
                                                     (buffer-top b)
                                                     (buffer-length b))
                                   ((tls-conn-prf conn) 12
                                    (tls-conn-master-secret conn)
                                    (string->utf8 "server finished")
                                    (list (md5->bytevector
                                           (md5-finish
                                            (tls-conn-handshakes-md5 conn)))
                                          (sha-1->bytevector
                                           (sha-1-finish
                                            (tls-conn-handshakes-sha-1 conn))))))
               (error 'get-tls-handshake "Bad verify_data in HANDSHAKE-FINISHED"))
             (hash!)
             (done!)
             'handshake-finished)

            ((= type TLS-HANDSHAKE-HELLO-REQUEST)
             (hash!)
             (done!)
             'hello-request)

            ;; TODO:
            (else
             (error 'get-tls-handshake-record
                    "an unknown handshake type arrived" type)))))

;;; Change cipher spec protocol

  ;; This protocol is used to install the new cipher specification,
  ;; which has been negotiated with the handshake protocol. The
  ;; protocol is supposed to be used to first enable encryption, but
  ;; the RFC says it should also be possible to rehandshake. There was
  ;; a small problem with that idea:

  ;; http://isc.sans.edu/diary.html?storyid=7534

  ;; TODO: implement the extension or whatever that allows secure
  ;; renegotiation.

  (define (put-tls-change-cipher-spec conn)
    (put-tls-record conn TLS-PROTOCOL-CHANGE-CIPHER-SPEC '(#vu8(1)))
    (tls-conn-client-cipher-set! conn TLS-RSA-WITH-3DES-EDE-CBC-SHA))

  (define (get-tls-change-cipher-spec conn)
    (cond ((and (= (buffer-length (tls-conn-inbuf conn)) 1)
                (= (read-u8 (tls-conn-inbuf conn) 0) 1)
                (= (tls-conn-server-cipher conn)
                   TLS-NULL-WITH-NULL-NULL)) ;a precaution
           (print ";Switching to encrypted records")
           (tls-conn-server-cipher-set! conn TLS-RSA-WITH-3DES-EDE-CBC-SHA)
           'change-cipher-spec)
          (else
           ;; TODO
           (close-tls conn)
           (error 'get-tls-change-cipher-spec
                  "The server sent a bad change-cipher-spec message"))))

;;; Application data protocol

  (define (put-tls-application-data conn data)
    (assert (not (= (tls-conn-server-cipher conn) TLS-NULL-WITH-NULL-NULL)))
    (put-tls-record conn TLS-PROTOCOL-APPLICATION-DATA
                    (list data)))

  (define (get-tls-application-data conn)
    (assert (not (= (tls-conn-server-cipher conn) TLS-NULL-WITH-NULL-NULL)))
    (let* ((b (tls-conn-inbuf conn))
           (appdata (bytevector-copy* (buffer-data b)
                                      (buffer-top b)
                                      (buffer-length b))))
      (print "#;application-data " appdata)

      (list 'application-data appdata))))
