;; -*- mode: scheme; coding: utf-8 -*-
;; Copyright © 2009 Göran Weinholt <goran@weinholt.se>
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#!r6rs

;; Transport Layer Security. RFC5246.

;; This library is under development and currently only works as a
;; very limited and quite slow client. It uses RSA to negotiate a
;; master secret, 3DES to encode data and SHA-1 to protect integrity.

;; The security of TLS in essence works like this: the server sends a
;; list of certificates, each signed by the next. The last certificate
;; is signed by a root certificate which you are supposed to have
;; downloaded from a trusted party. The first certificate contains the
;; server's public key. A few random bytes are generated by both the
;; client and the server. Then the client generates a few random bytes
;; that are called the premaster-secret and it encrypts them against
;; the server's public key. The server decrypts this and both sides
;; now have access to the premaster-secret without anyone being able
;; to read it off the network. Now both sides use all these random
;; numbers to generate the master secret and then use it to generate
;; key material for a symmetric cipher like 3DES. When this is done,
;; all messages have their checksums calculated with something like
;; SHA-1 and then encrypted with the cipher.

(library (weinholt net tls)
  (export make-tls-wrapper
          flush-tls-output
          put-tls-record get-tls-record
          put-tls-handshake
          put-tls-handshake-client-hello
          put-tls-handshake-certificate
          put-tls-handshake-client-key-exchange
          put-tls-change-cipher-spec
          put-tls-handshake-finished
          put-tls-application-data)
  (import (rnrs)
          (srfi :19 time)
          (weinholt crypto des)
          (weinholt crypto sha-1)
          (weinholt crypto md5)
          (weinholt crypto rsa)
          (weinholt crypto x509))

  (define TLS-VERSION-1.2 #x0303)
  (define TLS-VERSION-1.1 #x0302)
  (define TLS-VERSION-1.0 #x0301)
  (define SSL-VERSION-3.0 #x0300)       ;not gonna be supported
  (define TLS-VERSION TLS-VERSION-1.0)
  ;; TODO: fix the IV thing and upgrade to 1.1
  ;; TODO: implement tls-prf-sha256 and aes and upgrade to version 1.2
  (define tls-client-version-bytevector
    (let ((bv (make-bytevector 2)))
      (bytevector-u16-set! bv 0 TLS-VERSION (endianness big))
      bv))

  ;; A few cipher suites
  (define TLS-NULL-WITH-NULL-NULL #x0000)
  (define TLS-RSA-WITH-NULL-MD5 #x0001)
  (define TLS-RSA-WITH-NULL-SHA #x0002)
  (define TLS-RSA-WITH-NULL-SHA256 #x003B)
  (define TLS-RSA-WITH-RC4-128-MD5 #x0004)
  (define TLS-RSA-WITH-RC4-128-SHA #x0005)
  (define TLS-RSA-WITH-3DES-EDE-CBC-SHA #x000A) ;only one implemented
  (define TLS-RSA-WITH-AES-128-CBC-SHA #x002F)
  (define TLS-RSA-WITH-AES-256-CBC-SHA #x0035)
  (define TLS-RSA-WITH-AES-128-CBC-SHA256 #x003C)
  (define TLS-RSA-WITH-AES-256-CBC-SHA256 #x003D)

  (define (print . x) (for-each display x) (newline))

  (define (bv->string bv)
    (apply string-append
           (map (lambda (b)
                  (if (< b #x10)
                      (string-append "0" (number->string b 16))
                      (number->string b 16)))
                (bytevector->u8-list bv))))

  (define (bytevector-copy* bv start len)
    (let ((ret (make-bytevector len)))
      (bytevector-copy! bv start ret 0 len)
      ret))

  (define (bytevectors-length bvs)
    (do ((l bvs (cdr l))
         (sum 0 (+ sum (bytevector-length (car l)))))
        ((null? l) sum)))

  (define (bytevector-append x)
    (let ((length (bytevectors-length x)))
      (do ((bv (make-bytevector length))
           (x x (cdr x))
           (n 0 (+ n (bytevector-length (car x)))))
          ((null? x) bv)
        (bytevector-copy! (car x) 0 bv n (bytevector-length (car x))))))

  (define (u16be-list->bytevector x)
    (uint-list->bytevector x (endianness big) 2))

  (define (tls-prf-sha256 bytes secret label seeds)
    (error 'tls-prf-sha256 "not implemented"))

  (define (p-hash hash->bytevector hmac hash-length length secret seeds)
    ;; Expands the secret and seeds to at least `length' bytes, which
    ;; will be rounded to a multiple of the hash-length.
    (define (gen-A i max prev)
      (if (fx=? i max)
          '()
          (let ((a (hash->bytevector (hmac secret prev))))
            (cons prev (gen-A (fx+ i 1) max a)))))
    (bytevector-append
     (map (lambda (a) (hash->bytevector (apply hmac secret a seeds)))
          (gen-A 0
                 (div (+ length (- hash-length 1)) hash-length)
                 (hash->bytevector (apply hmac secret seeds))))))

  (define (tls-prf-md5-sha1 bytes secret label seeds)
    ;; Performs this operation from RFC4346:
    ;; PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
    ;;                          P_SHA-1(S2, label + seed)
    (let* ((half-length (div (+ (bytevector-length secret) 1) 2))
           (s1 (bytevector-copy* secret 0 half-length))
           (s2 (bytevector-copy* secret (- (bytevector-length secret)
                                           half-length)
                                 half-length))
           (seeds (cons label seeds)))
      (do ((p1 (p-hash md5->bytevector hmac-md5 16 bytes s1 seeds))
           (p2 (p-hash sha-1->bytevector hmac-sha-1 20 bytes s2 seeds))
           (i 0 (fx+ i 1))
           (ret (make-bytevector bytes)))
          ((= i bytes) ret)
        (bytevector-u8-set! ret i (fxxor (bytevector-u8-ref p1 i)
                                         (bytevector-u8-ref p2 i))))))

  (define-record-type tls-conn
    (fields (mutable client-cipher)
            (mutable server-cipher)
            (mutable compression)
            (mutable mac-key)
            (mutable seq-read)
            (mutable seq-write)
            (mutable version)
            (mutable server-certs)
            (mutable server-key)
            (mutable server-random)
            (mutable client-random)
            (mutable prf)
            (mutable master-secret)
            (mutable client-write-mac-secret)
            (mutable client-write-key)
            (mutable client-write-IV)
            (mutable server-write-mac-secret)
            (mutable server-write-key)
            (mutable server-write-IV)
            (mutable handshakes)
            (immutable server-name)
            (immutable inbuf)
            (immutable out)))

  (define (make-tls-wrapper in out server-name)
    (make-tls-conn TLS-NULL-WITH-NULL-NULL
                   TLS-NULL-WITH-NULL-NULL
                   #f
                   #f
                   0 0
                   TLS-VERSION
                   '()
                   'no-server-key-yet
                   'no-server-random
                   'no-client-random
                   'no-prf-yet
                   'no-master-secret-yet
                   'no-client-write-mac-secret-yet
                   'no-client-write-key-yet
                   'no-client-write-IV-yet
                   'no-server-write-mac-secret-yet
                   'no-server-write-key-yet
                   'no-server-write-IV-yet
                   '()
                   server-name
                   (make-buffer in)
                   out))

  (define (close-tls-immediately conn)
    (close-port (tls-conn-out conn))
    (close-port (buffer-port (tls-conn-inbuf conn))))

  ;; This buffer is similar to the one in x.sls. Could maybe be
  ;; merged. Also, TODO: raise proper conditions. output buffering
  ;; could be done from the end of the buffer.
  (define-record-type buffer
    (fields (immutable port)
            (mutable data)
            (mutable top)
            (mutable bottom))
    (protocol (lambda (p)
                (lambda (port)
                  (p port (make-bytevector 1024) 0 0)))))

  (define (buffer-read! buf n)
    (cond ((> (+ (buffer-bottom buf) n)
              (bytevector-length (buffer-data buf)))
           ;; Extend the buffer size
           (let* ((old (buffer-data buf))
                  (new (make-bytevector (* (bytevector-length old) 2))))
             (buffer-data-set! buf new)
             (bytevector-copy! old 0
                               new 0 (buffer-bottom buf))
             (buffer-read! buf n)))
          (else
           (let ((bytes-read (get-bytevector-n! (buffer-port buf)
                                                (buffer-data buf)
                                                (buffer-bottom buf) n)))
             (cond ((eof-object? bytes-read)
                    (error 'buffer-read! "port closed, whyyyy!?"))
                   ((< bytes-read n)
                    (error 'buffer-read! "premature end of data!! yikes!"))
                   (else
                    (buffer-bottom-set! buf (+ (buffer-bottom buf) n))))))))

  (define (buffer-reset! buf)
    (buffer-top-set! buf 0)
    (buffer-bottom-set! buf 0))

  (define (buffer-seek! buf offset)
    (when (> (+ (buffer-top buf) offset) (buffer-bottom buf))
      (error 'read-generic "attempt to seek past bottom of buffer"))
    (buffer-top-set! buf (+ (buffer-top buf) offset)))

  (define (read-generic buf ref size index)
    (when (> (+ index (buffer-top buf) size) (buffer-bottom buf))
      (error 'read-generic "attempt to read past bottom of buffer" ref))
    (ref (buffer-data buf) (+ (buffer-top buf) index) (endianness big)))

  (define (read-u8 buf index)
    (when (> (+ index (buffer-top buf) 1) (buffer-bottom buf))
      (error 'read-u8 "attempt to read past bottom of buffer" index))
    (bytevector-u8-ref (buffer-data buf) (+ (buffer-top buf) index)))

  (define (read-u16 buf i)
    (read-generic buf bytevector-u16-ref 2 i))

  (define (read-u24 buf index)
    (when (> (+ index (buffer-top buf) 3) (buffer-bottom buf))
      (error 'read-u24 "attempt to read past bottom of buffer" index))
    (let ((data (buffer-data buf))
          (offset (+ (buffer-top buf) index)))
      (fxior (fxarithmetic-shift-left (bytevector-u8-ref data (+ offset 0)) 16)
             (fxarithmetic-shift-left (bytevector-u8-ref data (+ offset 1)) 8)
             (bytevector-u8-ref data (+ offset 2)))))

  (define (read-u32 buf i)
    (read-generic buf bytevector-u32-ref 4 i))

;;; Record protocol

  (define TLS-PROTOCOL-CHANGE-CIPHER-SPEC 20)
  (define TLS-PROTOCOL-ALERT 21)
  (define TLS-PROTOCOL-HANDSHAKE 22)
  (define TLS-PROTOCOL-APPLICATION-DATA 23)

  (define (flush-tls-output conn)
    (flush-output-port (tls-conn-out conn)))

  (define (put-tls-record conn type data)
    ;; Take a list of data, split it into records and put the records
    ;; on the output port.
    (print "sending a record of type " type)
    (let ((out (tls-conn-out conn))
          (len (bytevectors-length data)))
      (put-u8 out type)
      ;; TLS version
      (put-u8 out (bitwise-arithmetic-shift-right (tls-conn-version conn) 8))
      (put-u8 out (fxand #xff (tls-conn-version conn)))

      (cond ((>= len (+ (expt 2 14) 2048))
             (error 'put-tls-record "TODO: overlong record" len))
            ((= (tls-conn-client-cipher conn) TLS-NULL-WITH-NULL-NULL)
             (put-u8 out (fxand #xff (bitwise-arithmetic-shift-right len 8)))
             (put-u8 out (fxand #xff len))
             (for-each (lambda (bv) (put-bytevector out bv)) data))
            (else
             (let* ((blocks-len (fx+ len 21))  ;content+sha-1+padbyte
                    ;; TODO: more than the minimum padding
                    (padding (- (fxand (fx+ blocks-len 7) -8)
                                blocks-len))
                    (padded-len (+ blocks-len padding))
                    (blocks (make-bytevector padded-len padding))
                    (mac-data (make-bytevector (+ 8 1 2 2))))

               (print "plaintext: " data)
               ;; TODO: if the sequence numbers above exceed 2^64-1, renegotiate
               (bytevector-u64-set! mac-data 0
                                    (tls-conn-seq-write conn)
                                    (endianness big))
               (tls-conn-seq-write-set! conn (+ (tls-conn-seq-write conn) 1))
               (bytevector-u8-set! mac-data 8 type)
               (bytevector-u16-set! mac-data 9 (tls-conn-version conn) (endianness big))
               (bytevector-u16-set! mac-data 11 len (endianness big))

               (sha-1-copy-hash! (apply hmac-sha-1
                                        (tls-conn-client-write-mac-secret conn)
                                        mac-data data)
                                 blocks len)

               (let ((plaintext (bytevector-append data)))
                 (bytevector-copy! plaintext 0
                                   blocks 0
                                   (bytevector-length plaintext)))

               ;; Encipher with 3DES-CBC
               (tdea-cbc-encipher! blocks
                                   (tls-conn-client-write-key conn)
                                   (tls-conn-client-write-IV conn)
                                   0 padded-len)
               
               (print "ciphertext: " blocks)
               (put-u8 out (fxand #xff (bitwise-arithmetic-shift-right padded-len 8)))
               (put-u8 out (fxand #xff padded-len))
               (put-bytevector out blocks))))))

  (define (get-tls-record conn)
    (let ((b (tls-conn-inbuf conn)))
      (buffer-reset! b)
      (buffer-read! b 5)
      (print "reading record type: " (read-u8 b 0))
      (print "reading record length: " (read-u16 b 3))
      ;; FIXME: defragment messages: read the header, set a flag and
      ;; then when coming back, don't reset the buffer. the protocol
      ;; is very clever and application data never needs to be
      ;; defragmented.
      (let ((type (read-u8 b 0))
            (len (read-u16 b 3)))
        (when (>= len (+ (expt 2 14) 2048))
          (error 'get-tls-record "overlong record from server..."))
        (buffer-reset! b)
        (buffer-read! b len)
        (when (= (tls-conn-server-cipher conn) TLS-RSA-WITH-3DES-EDE-CBC-SHA)
          (print "gonna decrypt now, see...")
          (tdea-cbc-decipher! (buffer-data b)
                              (tls-conn-server-write-key conn)
                              (tls-conn-server-write-IV conn)
                              (buffer-top b)
                              len)
          (let ((padding (bytevector-u8-ref (buffer-data b) (- (buffer-bottom b) 1))))
            ;; FIXME: verify the MAC
            (print "padding: " 20)
            (buffer-bottom-set! b (- (buffer-bottom b) padding 20 1))))

        (cond ((= type TLS-PROTOCOL-ALERT)
               (get-tls-alert-record conn))
              ((= type TLS-PROTOCOL-HANDSHAKE)
               (get-tls-handshake-record conn))
              ((= type TLS-PROTOCOL-CHANGE-CIPHER-SPEC)
               (get-tls-change-cipher-spec conn))
              ((= type TLS-PROTOCOL-APPLICATION-DATA)
               (get-tls-application-data conn))
              (else
               ;; TODO: send THEM the error
               (error 'get-tls-record "unimplemented record type" type))))))

  
;;; Alert protocol

  ;; TODO: friendly messages for all these alerts
  (define alert-descriptions
    '((0 . close-notify)
      (10 . unexpected-message)
      (20 . bad-record-mac)
      (21 . decryption-failed-RESERVED) ;never send this
      (22 . record-overflow)
      (30 . decompression-failure)
      (40 . handshake-failure)
      (41 . no-certificate-RESERVED)    ;deprecated
      (42 . bad-certificate)
      (43 . unsupported-certificate)
      (44 . certificate-revoked)
      (45 . certificate-expired)
      (46 . certificate-unknown)
      (47 . illegal-parameter)
      (48 . unknown-ca)
      (49 . access-denied)
      (50 . decode-error)
      (51 . decrypt-error)
      (60 . export-restriction-RESERVED) ;deprecated
      (70 . protocol-version)
      (71 . insufficient-security)
      (80 . internal-error)
      (90 . user-canceled)
      (100 . no-renegotiation)
      (110 . unsupported-extension)))

  (define (get-tls-alert-record conn)
    (let* ((b (tls-conn-inbuf conn))
           (level (read-u8 b 0))
           (description (read-u8 b 1))
           (desc* (or (assq description alert-descriptions)
                      (cons description 'unknown-alert-description))))
      (cond ((= level 2)
             (close-tls-immediately conn)
             (raise
               (condition
                (make-error)
                (make-i/o-error)
                (make-i/o-port-error (buffer-port (tls-conn-inbuf conn)))
                (make-message-condition "TLS alert (fatal, port closed)")
                (make-irritants-condition (list desc*)))))
            ((= level 1)
             (raise
               (condition
                (make-warning)
                (make-i/o-port-error (buffer-port (tls-conn-inbuf conn)))
                (make-message-condition "TLS alert (warning)")
                (make-irritants-condition (list desc*)))))
            ;; TODO: other levels give errors...
            )))


;;; Handshake protocol

  (define TLS-HANDSHAKE-HELLO-REQUEST 0)
  (define TLS-HANDSHAKE-CLIENT-HELLO 1)
  (define TLS-HANDSHAKE-SERVER-HELLO 2)
  (define TLS-HANDSHAKE-CERTIFICATE 11)
  (define TLS-HANDSHAKE-SERVER-KEY-EXCHANGE  12)
  (define TLS-HANDSHAKE-CERTIFICATE-REQUEST 13)
  (define TLS-HANDSHAKE-SERVER-HELLO-DONE 14)
  (define TLS-HANDSHAKE-CERTIFICATE-VERIFY 15)
  (define TLS-HANDSHAKE-CLIENT-KEY-EXCHANGE 16)
  (define TLS-HANDSHAKE-FINISHED 20)

  (define (put-tls-handshake conn type data)
    ;; Takes data from a handshake protocol and passes it to the
    ;; record protocol.
    (let ((bv (make-bytevector 4))
          (len (bytevectors-length data)))
      (bytevector-u32-set! bv 0 (bitwise-ior (bitwise-arithmetic-shift-left type 24)
                                             len)
                           (endianness big))
      ;; TODO: hash the handshake right here
      (tls-conn-handshakes-set! conn (cons (bytevector-append (cons bv data))
                                           (tls-conn-handshakes conn)))
      (put-tls-record conn TLS-PROTOCOL-HANDSHAKE (cons bv data))))

  (define (put-tls-handshake-client-hello conn)
    (define session-id '#vu8())
    (define cipher-suites (list TLS-RSA-WITH-3DES-EDE-CBC-SHA))
    (define compression-methods '(0))   ;null compression
    (let ((crandom (make-bytevector (+ 4 28))))
      ;; Client time + random bytes
      (bytevector-u32-set! crandom 0
                           (bitwise-and #xffffffff (time-second (current-time)))
                           (endianness big))
      (do ((i 4 (fx+ i 1))              ;FIXME: make portable
           (/dev/urandom (open-file-input-port "/dev/urandom")))
          ((fx=? i (bytevector-length crandom)))
        (bytevector-u8-set! crandom i (get-u8 /dev/urandom)))
      (tls-conn-client-random-set! conn crandom)

      ;; Extensions (RFC4366).
      ;; http://www.iana.org/assignments/tls-extensiontype-values

      ;; TODO: make this readable. And investigate why server_name is
      ;; a *list*....
      (let* ((sn (string->utf8 (tls-conn-server-name conn)))
             (server-name (bytevector-append (list #vu8(0) ;HostName
                                                   (u16be-list->bytevector
                                                    (list (+ 1 (bytevector-length sn))))
                                                   sn)))
             (server-name-list (bytevector-append (list
                                                   #vu8(0 0)      ;server_name
                                                   (u16be-list->bytevector
                                                    (list (bytevector-length server-name)))
                                                   server-name))))
        
        (put-tls-handshake
         conn TLS-HANDSHAKE-CLIENT-HELLO
         (list tls-client-version-bytevector
               crandom
               (u8-list->bytevector (list (bytevector-length session-id)))
               session-id
               (uint-list->bytevector (list (* 2 (length cipher-suites))) (endianness big) 2)
               (uint-list->bytevector cipher-suites (endianness big) 2)
               (u8-list->bytevector (cons (length compression-methods)
                                          compression-methods))
               (u16be-list->bytevector (list (bytevector-length server-name-list)))
               server-name-list)))))


  (define (put-tls-handshake-certificate conn)
    ;; no certificates to give
    (put-tls-handshake conn TLS-HANDSHAKE-CERTIFICATE
                       (list '#vu8(0 0 0))))

  (define (put-tls-handshake-client-key-exchange conn)
    (let* ((premaster-secret (make-bytevector 48))
           (keylen (rsa-public-key-byte-length (tls-conn-server-key conn)))
           (bv (make-bytevector (+ 2 keylen))))
      ;; Construct the premaster secret with our version number and 46
      ;; random bytes.
      (bytevector-u16-set! premaster-secret 0 TLS-VERSION (endianness big))
      (do ((i 2 (+ i 1))                ;FIXME: make portable
           (/dev/urandom (open-file-input-port "/dev/urandom")))
          ((= i (bytevector-length premaster-secret)))
        (bytevector-u8-set! premaster-secret i (get-u8 /dev/urandom)))

      (bytevector-u16-set! bv 0 keylen (endianness big))
      (bytevector-uint-set! bv 2
                            (rsa-pkcs1-encrypt premaster-secret
                                               (tls-conn-server-key conn))
                            (endianness big) keylen)
      (print "plaintext premaster secret: " (bv->string premaster-secret))
      (print "client random: " (bv->string (tls-conn-client-random conn)))
      (print "server random: " (bv->string (tls-conn-server-random conn)))

      (tls-conn-master-secret-set! conn ((tls-conn-prf conn) 48
                                         premaster-secret
                                         (string->utf8 "master secret")
                                         (list (tls-conn-client-random conn)
                                               (tls-conn-server-random conn))))

      (print "master secret: " (bv->string (tls-conn-master-secret conn)))

      ;; Generate cryptographical material from the master key
      (let* ((hash-size 20)             ;sha-1
             (key-size 24)              ;3des-cbc
             (IV-size 8)                ;3des-cbc
             (key-block ((tls-conn-prf conn) (* 2 (+ hash-size key-size IV-size))
                         (tls-conn-master-secret conn)
                         (string->utf8 "key expansion")
                         (list (tls-conn-server-random conn)
                               (tls-conn-client-random conn)))))

        (print "key block: " (bv->string key-block))

        (tls-conn-client-write-mac-secret-set! conn (bytevector-copy* key-block 0 hash-size))
        (tls-conn-server-write-mac-secret-set! conn (bytevector-copy* key-block hash-size hash-size))
        (let ((client-write-key (bytevector-copy* key-block (* 2 hash-size) key-size))
              (server-write-key (bytevector-copy* key-block (+ key-size (* 2 hash-size)) key-size)))
          (tls-conn-client-write-key-set! conn (tdea-permute-key client-write-key))
          (tls-conn-server-write-key-set! conn (tdea-permute-key server-write-key))
          (tls-conn-client-write-IV-set! conn (bytevector-copy* key-block (+ (* 2 key-size) (* 2 hash-size)) IV-size))
          (tls-conn-server-write-IV-set! conn (bytevector-copy* key-block (+ IV-size (* 2 key-size) (* 2 hash-size)) IV-size))

          (print "client-write-mac-secret: " (bv->string (tls-conn-client-write-mac-secret conn)))
          (print "server-write-mac-secret: " (bv->string (tls-conn-server-write-mac-secret conn)))
          (print "client-write-key: " (bv->string client-write-key))
          (print "server-write-key: " (bv->string server-write-key))
          (print "client-write-IV: " (bv->string (tls-conn-client-write-IV conn)))
          (print "server-write-IV: " (bv->string (tls-conn-server-write-IV conn)))

          (bytevector-fill! key-block 0)
          (bytevector-fill! premaster-secret 0)

          (put-tls-handshake conn TLS-HANDSHAKE-CLIENT-KEY-EXCHANGE
                             (list bv))))))



  (define (put-tls-handshake-finished conn)
    ;; PRF(master_secret, finished_label, MD5(handshake_messages) +
    ;;                         SHA-1(handshake_messages)) [0..11];
    (let ((handshakes (reverse (tls-conn-handshakes conn))))
      ;; TODO: hash the handshakes as they come, don't save them
      (put-tls-handshake conn TLS-HANDSHAKE-FINISHED
                         (list ((tls-conn-prf conn) 12
                                (tls-conn-master-secret conn)
                                (string->utf8 "client finished")
                                (list (md5->bytevector (apply md5 handshakes))
                                      (sha-1->bytevector (apply sha-1 handshakes))))))))


  (define (get-tls-handshake-record conn)
    (let* ((b (tls-conn-inbuf conn))
           (type (read-u8 b 0))
           (length (read-u24 b 1)))
      ;; FIXME: might be fragmented, check the length...

      (when (> length (- (buffer-bottom b) (buffer-top b)))
        (print (bv->string (buffer-data b)))
        (error 'get-tls-handshake-record "FIXME: short record" length))

      (unless (= type TLS-HANDSHAKE-HELLO-REQUEST)
        (tls-conn-handshakes-set! conn (cons (bytevector-copy* (buffer-data b)
                                                               (buffer-top b)
                                                               (+ 4 length))
                                             (tls-conn-handshakes conn))))
      (buffer-seek! b 4)

      (cond ((= type TLS-HANDSHAKE-SERVER-HELLO)
             ;; The server replied (presumably, check this later) to
             ;; the CLIENT-HELLO message.
             (print "server says hello.")
             (tls-conn-version-set! conn (read-u16 b 0))
             (print "version " (number->string (tls-conn-version conn) 16))
             (cond ((= (tls-conn-version conn) TLS-VERSION-1.2)
                    (tls-conn-prf-set! conn tls-prf-sha256))
                   (else
                    (tls-conn-prf-set! conn tls-prf-md5-sha1)))

             (print "server time: " (read-u32 b 2))

             (let ((srandom (make-bytevector (+ 4 28) 0)))
               (bytevector-copy! (buffer-data b) (+ 2 (buffer-top b))
                                 srandom 0
                                 (bytevector-length srandom))
               (tls-conn-server-random-set! conn srandom))

             (buffer-seek! b (+ 2 4 28))
             (print "session length: "  (read-u8 b 0))
             (buffer-seek! b (+ 1 (read-u8 b 0))) ;skip session

             (print "cipher suite: " (read-u16 b 0))
             (print "compression method: " (read-u8 b 2))
             'handshake-server-hello)

            ((= type TLS-HANDSHAKE-CERTIFICATE)
             (print "server sends his certs")
             (let ((certs-end (+ (buffer-top b) 3 (read-u24 b 0))))
               (buffer-seek! b 3)
               (let lp ((certs '()))
                 (cond ((= certs-end (buffer-top b))
                        (let* ((certs (reverse certs))
                               (result (verify-certificate-chain certs)))
                          (print "certificate chain verification: " result)
                          (tls-conn-server-key-set! conn (public-key<-certificate
                                                          (car certs)))
                          (tls-conn-server-certs-set! conn certs)
                          'handshake-certificate))
                       (else
                        (let* ((cert-len (read-u24 b 0))
                               (cert (certificate<-bytevector (buffer-data b)
                                                              (+ 3 (buffer-top b))
                                                              (+ 3 (buffer-top b)
                                                                 cert-len))))
                          (print "CERT LEN: " cert-len)
                          (buffer-seek! b (+ cert-len 3))
                          (lp (cons cert certs))))))))

            ((= type TLS-HANDSHAKE-SERVER-HELLO-DONE)
             (print "server has finished sending hellos")
             'handshake-server-hello-done)

            ((= type TLS-HANDSHAKE-CERTIFICATE-REQUEST)
             (print "server requests a client certificate! well well well!")
             'handshake-certificate-request)

            ((= type TLS-HANDSHAKE-FINISHED)
             (print "server is sending us the verification codes")
             'handshake-finished)

            ;; TODO:
            (else
             (error 'get-tls-handshake-record
                    "an unknown handshake type arrived" type)))))


;;; Change cipher spec protocol

  (define (put-tls-change-cipher-spec conn)
    (put-tls-record conn TLS-PROTOCOL-CHANGE-CIPHER-SPEC
                    '(#vu8(1)))
    (tls-conn-client-cipher-set! conn TLS-RSA-WITH-3DES-EDE-CBC-SHA))

  (define (get-tls-change-cipher-spec conn)
    (let ((msg (read-u8 (tls-conn-inbuf conn) 0)))
      (cond ((= msg 1)
             (print "server cipher spec changed")
             (tls-conn-server-cipher-set! conn TLS-RSA-WITH-3DES-EDE-CBC-SHA)
             'change-cipher-spec)
            (else
             ;; TODO
             (print "unexpected and so on...")))))

;;; Application data protocol

  (define (put-tls-application-data conn data)
    (put-tls-record conn TLS-PROTOCOL-APPLICATION-DATA
                    (list data)))

  (define (get-tls-application-data conn)
    (let* ((b (tls-conn-inbuf conn))
           (appdata (bytevector-copy* (buffer-data b)
                                      (buffer-top b)
                                      (- (buffer-bottom b) (buffer-top b)))))
      (print "Application data: " (utf8->string appdata))
      
      'application-data)))
